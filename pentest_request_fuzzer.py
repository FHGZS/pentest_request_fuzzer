#coding=utf-8
from burp import IBurpExtender
from burp import IContextMenuFactory
from burp import IBurpExtenderCallbacks
from burp import IHttpRequestResponse
from burp import ITextEditor
from javax.swing import JMenuItem
from javax.swing import JMenu
import subprocess
from java.util import ArrayList
from java.awt.event import ActionListener
from burp import IContextMenuInvocation
from burp import IParameter

import base64
import urllib2
import urllib

print '[+]Install successed!\n'


class ActionHandler(ActionListener):

	def __init__(self, callbacks, menu_name, helper):
		self.callbacks = callbacks
		#self.invocations = invocations
		self.menu_name = menu_name
		self._helpers = helper


	def actionPerformed(self, actionEvent):
		self.send_resp()

	def send_resp(self):

		messageInfo = invocations.getSelectedMessages()[0]


		#for line in messageInfo.getRequest().tostring().splitlines():
		request = messageInfo.getRequest()

		#requestInfo = self._helpers.analyzeRequest(currentRequest_info.getRequest())
		analyzedResponse = self._helpers.analyzeRequest(request)
		headers = analyzedResponse.getHeaders()
		req_url = str(messageInfo.getUrl())
		paras =	analyzedResponse.getParameters()

		headers = analyzedResponse.getHeaders()

		content_length  = ""
		for header in headers:
			#if header.startswith("Cookie: "):
			#	cookie = header[8:]
			if header.startswith("Host: "):
				host = header[6:]
			elif header.startswith("Content-Length: "):
				content_length = header[16:]
			else:
				pass
		para_str = ""
		end_para_str = ""

		for para in paras:
			#print para.getType()
			#print para.getName()
			#print len(paras)
			#print dir(para)
			#print para.getType()

			#print IParameter.PARAM_BODY
			#if not para.getType() == IParameter.PARAM_URL:
			if para.getType() != 1 and para.getType() != 0:
				continue
			para_name = para.getName()
			para_value = para.getValue()
			if len(paras) == 1:
				end_para_str = base64.b64encode(para_name+"="+para_value)
				break
			para_str = para_str + '&' + para_name+"="+para_value
		if end_para_str == "":
			end_para_str = base64.b64encode(para_str.lstrip('&'))
		#cookie,url,selected_textï¼Œdetect_type
		start, end = invocations.getSelectionBounds()
		message = invocations.getSelectedMessages()[0].getRequest()
		selected_text = self._helpers.bytesToString(message)[start:end]
		print "[+]selected_text:"+selected_text
		#print "[+]cookie:" + cookie
		#print "[+]req_url:" + req_url
		print "[+]detect_type:" + self.menu_name
		print "[+]content_length:" + content_length
		print "[+]host:" + host
		print "[+]para_str:" + end_para_str
		print '[+]Start to sending to proxy...'

		body_base64 = base64.b64encode(self._helpers.bytesToString(message))

		posturl = 'http://127.0.0.1:8776/server.py'
		data = {'request':body_base64,'specific_para':selected_text,'detect_type':self.menu_name, 'host':host, 'content_length':content_length, 'para_str':end_para_str }
		#data = {'url': req_url,'cookie':cookie,'specific_para':selected_text,'detect_type':self.menu_name}
		req = urllib2.Request(posturl)
		data = urllib.urlencode(data)
		opener = urllib2.build_opener()
		response = opener.open(req, data).read()
		print '[+]Sending ended...'






class BurpExtender(IBurpExtender, IContextMenuFactory, ITextEditor, IContextMenuInvocation, IHttpRequestResponse):

	items = ['Full_Detect','xss_detect','url_redirect','file_download','file_read','pass_by']


	def registerExtenderCallbacks(self, callbacks):
		self._actionName = "pentest_request_fuzzer"
		self._helers = callbacks.getHelpers()
		self._callbacks = callbacks
		#self._helper = callbacks.getHelpers()
		callbacks.setExtensionName("pentest_request_fuzzer")
		callbacks.registerContextMenuFactory(self)

		self.menuitems = dict()
		self.generate_menu_items()
		#self,currentRequest = currentRequest

		#callbacks.registerHttpListener(self)

		return 



	def createMenuItems(self, invocation):
		global invocations
		invocations = invocation


		menuItemList = ArrayList()
		#self._contextMenuData = contextMenuInvocation.getSelectedMessages()
		submenu = JMenu(self._actionName)

		for menuitem in sorted(self.menuitems):
			submenu.add(menuitem)
		menuItemList.add(submenu)

		return menuItemList


	def generate_menu_items(self):

		for k in self.items:
			#print k + '\n'
			#menuitem = JMenuItem(k, actionPerformed=self.menuItemClicked)
			menuitem = JMenuItem(k)

			#menu.append(JMenuItem(self._actionName, None , actionPerformed= lambda x, inv=invocation: self.sqlMapScan(inv)))
			menuitem.addActionListener(ActionHandler(self._callbacks, k, self._helers))

			self.menuitems[menuitem] = k


